name: Deploy Python App

on:
  push:
    branches:
      - step-6_ci-cd
    paths:
      - 'python-app/**'
      - 'manifests/python-app.yaml'
      - '.github/workflows/python-app.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: 'Docker image tag (leave empty for commit SHA)'
        required: false
        type: string

env:
  APP_NAME: customer-profile-api
  DOCKERFILE_PATH: python-app/Dockerfile
  MANIFEST_PATH: manifests/python-app.yaml

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set environment variables
        id: vars
        run: |
          ENV_NAME="${{ github.event.inputs.environment || 'dev' }}"
          echo "ENVIRONMENT_NAME=$ENV_NAME" >> $GITHUB_ENV
          
          # Use provided tag or commit SHA
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          else
            IMAGE_TAG="${GITHUB_SHA::7}"
          fi
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          # Get infrastructure details from secrets/variables
          echo "RESOURCE_GROUP=${{ vars.AZURE_RESOURCE_GROUP || secrets.AZURE_RESOURCE_GROUP }}" >> $GITHUB_ENV
          echo "AKS_CLUSTER_NAME=${{ vars.AKS_CLUSTER_NAME || secrets.AKS_CLUSTER_NAME }}" >> $GITHUB_ENV
          echo "ACR_NAME=${{ vars.AZURE_CONTAINER_REGISTRY_NAME || secrets.AZURE_CONTAINER_REGISTRY_NAME }}" >> $GITHUB_ENV

      - name: Get ACR login server
        id: acr
        run: |
          ACR_LOGIN_SERVER=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer -o tsv)
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        run: |
          # Login to ACR
          az acr login --name ${{ env.ACR_NAME }}
          
          # Build image
          docker build \
            -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }} \
            -t ${{ env.ACR_LOGIN_SERVER }}/${{ env.APP_NAME }}:latest \
            -f ${{ env.DOCKERFILE_PATH }} \
            python-app/
          
          # Push images
          docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          docker push ${{ env.ACR_LOGIN_SERVER }}/${{ env.APP_NAME }}:latest
          
          echo "### Docker Image Built âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${{ env.ACR_LOGIN_SERVER }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}" >> $GITHUB_STEP_SUMMARY

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Update Kubernetes manifest
        run: |
          # Update image in manifest
          sed -i "s|image: .*${{ env.APP_NAME }}:.*|image: ${{ env.ACR_LOGIN_SERVER }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}|g" ${{ env.MANIFEST_PATH }}
          
          # Show the updated manifest
          echo "Updated manifest:"
          cat ${{ env.MANIFEST_PATH }}

      - name: Deploy to AKS
        run: |
          kubectl apply -f ${{ env.MANIFEST_PATH }}
          
          echo "### Deployed to AKS âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster:** ${{ env.AKS_CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY

      - name: Wait for deployment rollout
        run: |
          kubectl rollout status deployment/${{ env.APP_NAME }} --timeout=5m
          
      - name: Verify deployment
        run: |
          echo "Deployment status:"
          kubectl get deployment ${{ env.APP_NAME }}
          
          echo ""
          echo "Pods:"
          kubectl get pods -l app=${{ env.APP_NAME }}
          
          echo ""
          echo "Service:"
          kubectl get service ${{ env.APP_NAME }}

      - name: Get service endpoint
        id: endpoint
        run: |
          # Wait for external IP
          echo "Waiting for LoadBalancer external IP..."
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get service ${{ env.APP_NAME }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "EXTERNAL_IP=$EXTERNAL_IP" >> $GITHUB_ENV
              echo "external_ip=$EXTERNAL_IP" >> $GITHUB_OUTPUT
              echo "### Service Endpoint ðŸŒ" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**URL:** http://$EXTERNAL_IP" >> $GITHUB_STEP_SUMMARY
              break
            fi
            sleep 10
          done

      - name: Run smoke tests
        if: steps.endpoint.outputs.external_ip != ''
        run: |
          # Wait a bit for the service to be ready
          sleep 30
          
          # Test health endpoint
          echo "Testing health endpoint..."
          curl -f http://${{ env.EXTERNAL_IP }}/health || echo "Health check failed"

    outputs:
      image_tag: ${{ steps.vars.outputs.image_tag }}
      external_ip: ${{ steps.endpoint.outputs.external_ip }}
